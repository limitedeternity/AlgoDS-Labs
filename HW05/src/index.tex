\problemset{Домашнее задание}

\begin{problem}
    Есть улица длины $l$, которая освещается $n > 0$ фонарями, $i$-й фонарь находится в
    точке с вещественной координатой $a_i$. Фонарь освещает все точки улицы,
    которые находятся от него на расстоянии не больше d, где $d$~-- некоторое
    положительное число, общее для всех фонарей.
    Найдите минимальное $d$, при котором вся улица освещена. Время работы $O(n)$, $a_i$ не отсортированы.
\end{problem}

\begin{solution}
    \dots
\end{solution}


\begin{problem}
    Опишите, как изменится время работы \texttt{QuickSort}, если в качестве \texttt{pivot} брать

    \begin{enumerate}[a)]
        \item среднее арифметическое элементов
        \item равномерно распределенное случайное число из отрезка $[\min(a), \max(a)]$
    \end{enumerate}
\end{problem}

\begin{solution}
    Средняя временная сложность \texttt{QuickSort} составляет $O(n \log{n})$, независимо от стратегии выбора
    \texttt{pivot}. Это объясняется тем, что в среднем \texttt{pivot} делит массив на две примерно равные половины.

    Однако, если постараться и очень плохо выбрать \texttt{pivot}, можно получить временную сложность $O(n^2)$,
    что является худшей временной сложностью, которой может достичь \texttt{QuickSort}.
\end{solution}


\begin{problem}
    Будем называть массив \texttt{a[0..n-1]} \textbf{отсортированным на} 90\%, или
    \textbf{почти отсортированным}, если из него можно так вычеркнуть 10\% элементов,
    чтобы оставшиеся оказались в отсортированном порядке.

    Попытаемся построить эффективный алгоритм, по входному массиву отличающий два случая:
    \begin{itemize}
    	\item массив полностью отсортирован
    	\item массив \textbf{не} почти отсортирован
    \end{itemize}

	Будем рассматривать только массивы, все элементы которых различны.

    Рассмотрим следующий алгоритм:
    \medskip\noindent
    {
        \normalfont\lstinputlisting[language=Python,title={Листинг алгоритма}]{source/check-sort.py}
    }

    Докажите (и предъявите конкретное значение $k$), что при выборе некоторой
    константы $k$ данный алгоритм
    \begin{itemize}
      \item выдаёт всегда \texttt{True} для отсортированного массива;
      \item выдает \texttt{False} с вероятностью хотя бы $\frac{2}{3}$,
        если массив не отсортирован на 90\%.
    \end{itemize}

    {
        \footnotesize \textbf{Подсказка}: оцените сверху количество элементов,
        которые находятся двоичным поиском.
    }
\end{problem}

\begin{solution}
    \dots
\end{solution}


\begin{problem}
    Дан набор строчек $s_i$, состоящих из десятичных цифр, суммарной длины $n$.
    Найдите в каком порядке их нужно сконкатенировать, чтобы получившееся в результате
    число было максимальным. $O(n^2 \log{n})$.
\end{problem}

\begin{solution}
    \medskip\noindent
    \lstinputlisting[language=Python,title={Задача 4. Реализация на Python}]{source/Task4.py}

    \texttt{TimSort} имеет временную сложность $O(n \log{n})$, если сравнение двух элементов выполняется за одну
    операцию.

    Если максимальная длина среди строк в массиве составляет $S$, то сравнение двух строк потребует максимум $S$ операций.
    Следовательно, временная сложность составляет $O(Sn \log{n})$.

    Поскольку формулировкой задачи введено дополнительное условие, что суммарная длина строк в массиве равна $n$, то
    выходит, что $S \le n$. Таким образом, оценка временной сложности приобретает вид $O(n^2 \log{n})$.
\end{solution}


\begin{problem}
    Есть массив, состоящий из $n$ натуральных чисел. Найти минимальное натуральное число,
    которого нет в массиве, за $O(n)$ времени и $O(1)$ дополнительной памяти.
    Входной массив доступен для записи.
\end{problem}

\begin{solution}
    \medskip\noindent
    \lstinputlisting[language=Python,title={Задача 5. Реализация на Python}]{source/Task5.py}
\end{solution}


\subsection*{Дополнительные задачи}

\begin{problem}
    Пусть алгоритм $A(X, i)$ корректно находит $i$-ый по порядку элемент
    в любом массиве чисел $X$ и использует только попарные сравнения элементов.
    Покажите, что, в массиве $X$ можно найти все элементы, меньшие $i$-ого,
    и все элементы, большие $i$-ого, используя только результаты сравнений,
    которые сделает $A(X, i)$.
\end{problem}

\begin{solution}
    \dots
\end{solution}


\clearpage
