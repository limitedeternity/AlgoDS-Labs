\problemset{Домашнее задание}

\begin{problem}
    Определить асимптотику $T(n) = 2T(\lfloor \log n \rfloor) + 2^{\log^* n}$, где $\log^* n$ ---
    \href{https://en.wikipedia.org/wiki/Iterated_logarithm}{итерированный логарифм}.
\end{problem}

\begin{solution}
    $\Omega(2^{\log^* n})$
\end{solution}


\begin{problem}
    Даны два отсортированных массива $a$ и $b$ длины $n$, сгенерировать все попарные суммы $a_i + b_j$
    в сортированном порядке.
    \begin{enumerate}[a)]
        \item За время $O(n^2 \log n)$.
        \item За время $O(n^3)$ с использованием $O(n)$ дополнительной памяти.
        \item \texttt{[Дополнительная задача]} За время $O(n^3)$ с использованием $O(1)$ дополнительной памяти.
    \end{enumerate}
\end{problem}

\begin{solution}
    \leavevmode\vspace{1pt}
    \begin{enumerate}[a)]
        \item
        \lstinputlisting[language=Python,title={Задача 2(a). Реализация на Python}]{code/Task_2a.py}
    \end{enumerate}
\end{solution}


\begin{problem}
    Есть $m$ стойл с координатами $x_1, \ldots, x_m$ и $n$ коров. Расставить коров по стойлам (не более одной в стойло) так,
    чтобы минимальное расстояние между коровами было максимально за время $O(m (\log{m} + \log{x_{\max}}))$.
\end{problem}

\begin{solution}
    \leavevmode\vspace{1pt}
    \lstinputlisting[language=Python,title={Задача 3. Реализация на Python}]{code/Task_3.py}
\end{solution}


\begin{problem}
    \leavevmode\vspace{1pt}
    \begin{enumerate}[a)]
        \item Покажите, как реализовать слияние $k$ отсортированных массивов суммарной длины $n$ в один отсортированный массив за время $O(n \log k)$.
        \item Оцените время работы сортировки слиянием, разбивающей каждый раз массив не на две части, а на $k$.
    \end{enumerate}
\end{problem}

\begin{solution}
    \leavevmode\vspace{1pt}
    \begin{enumerate}[a)]
        \item
        \lstinputlisting[language=Python,title={Задача 4(a). Реализация на Python}]{code/Task_4a.py}
    \end{enumerate}
\end{solution}


\begin{problem}
    Докажите, что для поиска максимума в массиве различных чисел потребуется как минимум $n-1$ сравнение.
\end{problem}

\begin{solution}
    \leavevmode\vspace{1pt}
    \lstinputlisting[language=Coq,title={Листинг доказательства}]{proofs/Task_5.v}
\end{solution}


\begin{problem}
    Найти второй максимум в массиве за $n + O(\log n)$ сравнений. \\
    {\footnotesize \textbf{Подсказка}: посмотрите на алгоритм сортировки слиянием \textit{снизу} и уберите все лишнее}
\end{problem}

\begin{solution}
    \leavevmode\vspace{1pt}
    \lstinputlisting[language=Python,title={Задача 6. Реализация на Python}]{code/Task_6.py}
\end{solution}


\begin{problem}
    Дано $2n - 1$ коробок с чёрными и белыми шарами.  В $i$-ой коробке находятся $w_i$ белых и $b_i$ чёрных шаров.
    Всего в коробках находятся $W$ белых и $B$ чёрных шаров.
    Требуется выбрать $n$ коробок таким образом, чтобы суммарное число белых шаров в них было не менее $\frac{W}{2}$,
    а чёрных не менее $\frac{B}{2}$. Решить за $O(n \log n)$.
\end{problem}

\begin{solution}
    \dots
\end{solution}


\subsection*{Дополнительные задачи}

\begin{problem}
    Найти количество \texttt{AVL} деревьев высоты $h$ из $n$ вершин по простому модулю $p$ за время $O(h n^{\log_2 3})$
    (\texttt{AVL} дерево --- корневое двоичное дерево, в котором у каждой вершины высоты двух дочерних поддеревьев отличаются не более, чем на $1$).\\
    {
        \footnotesize \textbf{Подсказка}: выразите количество деревьев рекуррентой от $n$ и $h$ и сведите задачу к умножению многочленов
        (могут помочь производящие функции)
    }
\end{problem}

\begin{solution}
    \dots
\end{solution}


\begin{problem}
    \textbf{K-Best}. Есть $n$ предметов, у каждого есть своя стоимость $c_i$ и вес $w_i$. Веса и стоимости не превосходят $M$.
    Выберите ровно $k$ предметов так, чтобы их суммарная удельная стоимость $\left(\sum c_i\right) / \left(\sum w_i\right)$ была максимальна,
    за время $O(n \log M)$.
\end{problem}


\begin{solution}
    \dots
\end{solution}


\clearpage
