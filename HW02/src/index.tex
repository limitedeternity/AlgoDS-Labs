\problemset{Домашнее задание}

\begin{problem}
    Дано двоичное число, заданное в виде битового массива $a$ длины $n$ (от младших битов к старшим), к которому
    затем $m$ раз прибавляют единицу простейшим алгоритмом:

    {
        \normalfont\begin{lstlisting}[title={Листинг алгоритма}]
        int carry = 1;
        for (int i = 0; carry > 0 && i < n; i++)
        {
            carry += a[i];
            a[i] = carry % 2;
            carry = carry / 2;
        }
        \end{lstlisting}
    }

    Числа выбраны так, что переполнения не происходит. Докажите методом потенциалов, что суммарное время
    работы будет $O(n + m)$.\\
    {\footnotesize \textbf{Подсказка}: оцените истинное время работы операции, и придумайте потенциал, который падает на примерно равную величину, чтобы амортизированное время получалось константным.}
\end{problem}

\begin{solution}
    \dots
\end{solution}


\begin{problem}
    Вам дан массив из $n$ элементов и
    список из $m$ запросов $\mathtt{add}(x, l, r)$: прибавить $x$ к каждому
    элементу на отрезке $[l, r]$. За $O(n + m)$ выведите массив,
    получающийся из исходного после выполнения заданных запросов.\\
    {\footnotesize \textbf{Подсказка}: подумайте, какая операция <<обратна>> вычислению префиксных сумм на массиве.}
\end{problem}

\begin{solution}
    \leavevmode\vspace{1pt}
    \lstinputlisting[language=Python,title={Реализация на Python}]{code/Task_2.py}

    Представим, что у нас есть конечный автомат, который обрабатывает входную последовательность, добавляя к каждому
    элементу своё
    внутреннее состояние. На это состояние можно влиять, передавая значение-дельту, которую следует прибавить к нему.
    Нетрудно заметить, что положительная дельта увеличит состояние, а отрицательная, напротив - его
    уменьшит. Этот механизм позволит нам применять преобразования к диапазонам внутри входной последовательности.

    Рассмотрим первый цикл, время работы которого составляет \( O(m) \), где \( m \) - длина последовательности запросов.
    Этот цикл формирует последовательность дельт, на которую будет ориентироваться конечный автомат.

    Второй же цикл, время работы которого составляет \( O(n) \), где \( n \) - длина входной последовательности,
    является тем самым конечным автоматом, применяющим преобразования.

    Таким образом, суммарное время работы алгоритма составляет \( O(m + n) \).
\end{solution}


\begin{problem}
    Дано число, представленное $n$ цифрами в $d$-ичной записи без
    ведущих нулей.  Из числа требуется вычеркнуть
    \begin{enumerate}[(a)]
        \item произвольное количество цифр
        \item ровно $k$ цифр
    \end{enumerate}
    так, чтобы результат был максимальным. Время работы $O(n)$ вне зависимости от $d$ и $k$.
\end{problem}

\begin{solution}
    \dots
\end{solution}


\begin{problem}
    Вам дана строка из трёх типов скобок. Найдите самую длинную ее
    подстроку, являющуюся правильной скобочной последовательностью. Время работы $O(n)$.
\end{problem}

\begin{solution}
    \leavevmode\vspace{1pt}
    \lstinputlisting[language=Python,title={Реализация на Python}]{code/Task_4.py}

    Алгоритм работает за \( O(n) \) времени и \( O(n) \) памяти -- требуется один проход по скобочной
    последовательности, в ходе которого осуществляется построение стека для отслеживания позиций открывающих скобок.
    Также отметим, что взаимодействие со стеком выполняется за \( O(1) \) времени по определению.

    Алгоритм тривиально модифицируется для извлечения искомой подстроки -- достаточно заменить обращение к функции
    $\mathtt{max}$ на соответствующее условие и внутри него по стартовому и текущему индексам сохранять срез строки.
\end{solution}


\begin{problem}
    Дан массив целых чисел длины $n$. Найдите подотрезок с максимальной суммой за время $O(n)$,
    \begin{enumerate}[(a)]
        \item без ограничений на дополнительную память;
        \item имея возможность завести не более одного массива целых чисел длины $n$ плюс $O(1)$ памяти (исходный массив изменять нельзя).
    \end{enumerate}
\end{problem}

\begin{solution}
    \leavevmode\vspace{1pt}
    \lstinputlisting[language=Python,title={Реализация алгоритма Кадане на Python}]{code/Task_5.py}

    Алгоритм Кадане работает за \( O(n) \) времени и \( O(1) \) памяти -- требуется всего две
    дополнительные переменные и один проход по последовательности длины $n$.

    Для поддержания индексов-границ искомого подотрезка достаточно заменить обращения к функции $\mathtt{max}$
    соответствующими условиями. Стоимость изменений -- \( O(1) \) времени и \( O(1) \) памяти.

    Ниже приведено формальное доказательство корректности алгоритма Кадане:
    \lstinputlisting[title={Листинг доказательства}]{proofs/Task_5.v}
\end{solution}


\begin{problem}
    Дан массив из $n$ целых чисел из $[0 \ldots n-1]$ и число $k$. Найдите такие $l$ и $r$, что на отрезке $[l, r]$ встречается хотя бы $k$ различных элементов, или сообщите, что такого отрезка нет. Если таких отрезков несколько, выберите тот из них, длина которого минимальна. Время работы $O(n)$.
\end{problem}

\begin{solution}
    \dots
\end{solution}


\begin{problem}
    Дан массив целых чисел длины $n$. Найдите подотрезок длины
    от $L$ до $R$ с максимальной суммой. Время работы $O(n)$.
\end{problem}

\begin{solution}
    \leavevmode\vspace{1pt}
    \lstinputlisting[language=Python,title={Реализация на Python}]{code/Task_7.py}

    Для выполнения алгоритма требуется \( O((r - l + 1) \cdot n) = O(n) \) времени и \( O(1) \) памяти.
    Затраты по времени объясняются тем, что требуется \( r - l + 1 \) проходов по последовательности длины $n$ для порождения окон
    необходимых длин.
    В затратах по памяти примечательно использование дека в качестве контейнера для окна: \( \forall k, l \le k \le r :
    O(k \cdot 1) = O(1) \).
    Также отметим, что обращения к деку занимают \( O(1) \) времени по определению.

    Алгоритм тривиально модифицируется для извлечения окна с максимальной суммой, поскольку эти самые окна порождаются в
    явном виде в процессе работы алгоритма.
\end{solution}


\subsection*{Дополнительные задачи}

\begin{problem}
    Дан массив длины $n$ с целыми числами $a_i$, $-n \leq a_i \leq n$. Найдите подотрезок с максимальной суммой, длины от $L$ до $R$, содержащий от $A$ до $B$ различных чисел, за $O(n)$.
\end{problem}

\begin{solution}
    \dots
\end{solution}


\begin{problem}
    За \texttt{один проход} со стеком найти для каждого числа в массиве ближайшие к нему: меньшее его слева и меньшее либо равное ему справа.
\end{problem}

\begin{solution}
    \dots
\end{solution}


\begin{problem}
    Дана квадратная матрица из нулей и единиц. Найти наибольший по площади
    подпрямоугольник, состоящий только из нулей, за $O(n^2)$.
\end{problem}

\begin{solution}
    \dots
\end{solution}


\clearpage
