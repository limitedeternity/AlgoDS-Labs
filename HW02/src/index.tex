\problemset{Домашнее задание}

\begin{problem}
    Дано двоичное число, заданное в виде битового массива $a$ длины $n$ (от младших битов к старшим), к которому
    затем $m$ раз прибавляют единицу простейшим алгоритмом:

    {
        \normalfont\begin{lstlisting}[title={Листинг алгоритма}]
        int carry = 1;
        for (int i = 0; carry > 0 && i < n; i++)
        {
            carry += a[i];
            a[i] = carry % 2;
            carry = carry / 2;
        }
        \end{lstlisting}
    }

    Числа выбраны так, что переполнения не происходит. Докажите методом потенциалов, что суммарное время
    работы будет $O(n + m)$.\\
    {\footnotesize \textbf{Подсказка}: оцените истинное время работы операции, и придумайте потенциал, который падает на примерно равную величину, чтобы амортизированное время получалось константным.}
\end{problem}

\begin{solution}
    \dots
\end{solution}


\begin{problem}
    Вам дан массив из $n$ элементов и
    список из $m$ запросов $\mathtt{add}(x, l, r)$: прибавить $x$ к каждому
    элементу на отрезке $[l, r]$. За $O(n + m)$ выведите массив,
    получающийся из исходного после выполнения заданных запросов.\\
    {\footnotesize \textbf{Подсказка}: подумайте, какая операция <<обратна>> вычислению префиксных сумм на массиве.}
\end{problem}

\begin{solution}
    \leavevmode\vspace{1pt}
    \lstinputlisting[language=Python,title={Реализация на Python}]{code/Task_2.py}

    Представим, что у нас есть конечный автомат, который обрабатывает входную последовательность, добавляя к каждому
    элементу своё
    внутреннее состояние. На это состояние можно влиять, передавая значение-дельту, которую следует прибавить к нему.
    Нетрудно заметить, что положительная дельта увеличит состояние, а отрицательная, напротив - его
    уменьшит. Этот механизм позволит нам применять преобразования к диапазонам внутри входной последовательности.

    Рассмотрим первый цикл, время работы которого составляет \( O(m) \), где \( m \) - длина последовательности запросов.
    Этот цикл формирует последовательность дельт, на которую будет ориентироваться конечный автомат.

    Второй же цикл, время работы которого составляет \( O(n) \), где \( n \) - длина входной последовательности,
    является тем самым конечным автоматом, применяющим преобразования.

    Таким образом, суммарное время работы алгоритма составляет \( O(m + n) \).
\end{solution}


\begin{problem}
    Дано число, представленное $n$ цифрами в $d$-ичной записи без
    ведущих нулей.  Из числа требуется вычеркнуть
    \begin{enumerate}[(a)]
        \item произвольное количество цифр
        \item ровно $k$ цифр
    \end{enumerate}
    так, чтобы результат был максимальным. Время работы $O(n)$ вне зависимости от $d$ и $k$.
\end{problem}

\begin{solution}
    \dots
\end{solution}


\begin{problem}
    Вам дана строка из трёх типов скобок. Найдите самую длинную ее
    подстроку, являющуюся правильной скобочной последовательностью. Время работы $O(n)$.
\end{problem}

\begin{solution}
    \leavevmode\vspace{1pt}
    \lstinputlisting[language=Python,title={Реализация на Python}]{code/Task_4.py}

    Алгоритм работает за \( O(n) \) времени и \( O(n) \) памяти -- требуется один проход по скобочной
    последовательности, в ходе которого осуществляется построение стека для проверки баланса.
    Также отметим, что взаимодействие со стеком выполняется за \( O(1) \) времени по определению.

    Алгоритм тривиально модифицируется для получения информации о расположении искомой подстроки --
    достаточно заменить обращение к функции $\mathtt{max}$ на соответствующее условие, и внутри него вычислять стартовый
    индекс подстроки.
\end{solution}


\begin{problem}
    Дан массив целых чисел длины $n$. Найдите подотрезок с максимальной суммой за время $O(n)$,
    \begin{enumerate}[(a)]
        \item без ограничений на дополнительную память;
        \item имея возможность завести не более одного массива целых чисел длины $n$ плюс $O(1)$ памяти (исходный массив изменять нельзя).
    \end{enumerate}
\end{problem}

\begin{solution}
    \leavevmode\vspace{1pt}
    \lstinputlisting[language=Python,title={Реализация алгоритма Кадане на Python}]{code/Task_5.py}

    Алгоритм Кадане работает за \( O(n) \) времени и \( O(1) \) памяти -- требуется всего две
    дополнительные переменные и один проход по последовательности длины $n$.

    Для поддержания индексов-границ искомого подотрезка достаточно заменить обращения к функции $\mathtt{max}$
    соответствующими условиями. Стоимость изменений -- \( O(1) \) времени и \( O(1) \) памяти.

    Ниже приведено формальное доказательство корректности алгоритма Кадане:
    \lstinputlisting[title={Листинг доказательства}]{proofs/Task_5.v}
\end{solution}


\begin{problem}
    Дан массив из $n$ целых чисел из $[0 \ldots n-1]$ и число $k$. Найдите такие $l$ и $r$, что на отрезке $[l, r]$ встречается хотя бы $k$ различных элементов, или сообщите, что такого отрезка нет. Если таких отрезков несколько, выберите тот из них, длина которого минимальна. Время работы $O(n)$.
\end{problem}

\begin{solution}
    \dots
\end{solution}


\begin{problem}
    Дан массив целых чисел длины $n$. Найдите подотрезок длины
    от $L$ до $R$ с максимальной суммой. Время работы $O(n)$.
\end{problem}

\begin{solution}
    \leavevmode\vspace{1pt}
    \lstinputlisting[language=Python,title={Реализация на Python}]{code/Task_7.py}

    \begin{lstlisting}[title={Трассировочный вывод алгоритма}]
    deque([1]) 1 0

    deque([1, 2]) 3 3

    deque([1, 2, -5]) -2 3

    deque([1, 2, -5, 3]) 1 3

    deque([2, -5, 3]) 0 3
    deque([2, -5]) -3 3
    deque([2, -5, 3]) 0 3
    deque([2, -5, 3, 2]) 2 3

    deque([-5, 3, 2]) 0 3
    deque([-5, 3]) -2 3
    deque([-5, 3, 2]) 0 3
    deque([-5, 3, 2, -1]) -1 3

    deque([3, 2, -1]) 4 4
    deque([3, 2]) 5 5
    deque([3, 2, -1]) 4 5
    deque([3, 2, -1, 5]) 9 9

    deque([2, -1, 5]) 6 9
    deque([2, -1]) 1 9
    deque([2, -1, 5]) 6 9
    deque([2, -1, 5, -10]) -4 9

    deque([-1, 5, -10]) -6 9
    deque([-1, 5]) 4 9
    deque([-1, 5, -10]) -6 9
    deque([-1, 5, -10, 3]) -3 9

    deque([5, -10, 3]) -2 9
    deque([5, -10]) -5 9
    deque([5, -10, 3]) -2 9
    deque([5, -10, 3, 2]) 0 9
    \end{lstlisting}

    По трассе алгоритма видно, что его выполнение занимает \( O((r - l + 1) \cdot n) = O(n) \) времени ввиду
    <<зигзагообразного>> движения на каждый обрабатываемый элемент. Также отметим, что обращения к деку занимают \( O(1) \) времени по определению.

    Вычисление индексов-границ искомого подотрезка реализуется аналогично \textbf{Задаче 5}.
\end{solution}


\subsection*{Дополнительные задачи}

\begin{problem}
    Дан массив длины $n$ с целыми числами $a_i$, $-n \leq a_i \leq n$. Найдите подотрезок с максимальной суммой, длины от $L$ до $R$, содержащий от $A$ до $B$ различных чисел, за $O(n)$.
\end{problem}

\begin{solution}
    \dots
\end{solution}


\begin{problem}
    За \texttt{один проход} со стеком найти для каждого числа в массиве ближайшие к нему: меньшее его слева и меньшее либо равное ему справа.
\end{problem}

\begin{solution}
    \dots
\end{solution}


\begin{problem}
    Дана квадратная матрица из нулей и единиц. Найти наибольший по площади
    подпрямоугольник, состоящий только из нулей, за $O(n^2)$.
\end{problem}

\begin{solution}
    \dots
\end{solution}


\clearpage
